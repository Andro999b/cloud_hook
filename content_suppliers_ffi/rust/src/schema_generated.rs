// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod proto {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTENT_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTENT_TYPE: u8 = 4;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTENT_TYPE: [ContentType; 5] = [
  ContentType::Movie,
  ContentType::Anime,
  ContentType::Cartoon,
  ContentType::Series,
  ContentType::Manga,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContentType(pub u8);
#[allow(non_upper_case_globals)]
impl ContentType {
  pub const Movie: Self = Self(0);
  pub const Anime: Self = Self(1);
  pub const Cartoon: Self = Self(2);
  pub const Series: Self = Self(3);
  pub const Manga: Self = Self(4);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 4;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Movie,
    Self::Anime,
    Self::Cartoon,
    Self::Series,
    Self::Manga,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Movie => Some("Movie"),
      Self::Anime => Some("Anime"),
      Self::Cartoon => Some("Cartoon"),
      Self::Series => Some("Series"),
      Self::Manga => Some("Manga"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContentType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContentType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContentType {
    type Output = ContentType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContentType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContentType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContentType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MEDIA_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MEDIA_TYPE: u8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEDIA_TYPE: [MediaType; 2] = [
  MediaType::Video,
  MediaType::Manga,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MediaType(pub u8);
#[allow(non_upper_case_globals)]
impl MediaType {
  pub const Video: Self = Self(0);
  pub const Manga: Self = Self(1);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Video,
    Self::Manga,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Video => Some("Video"),
      Self::Manga => Some("Manga"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MediaType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MediaType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MediaType {
    type Output = MediaType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MediaType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MediaType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MediaType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTENT_MEDIA_ITEM_SOURCE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTENT_MEDIA_ITEM_SOURCE_TYPE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTENT_MEDIA_ITEM_SOURCE_TYPE: [ContentMediaItemSourceType; 3] = [
  ContentMediaItemSourceType::Video,
  ContentMediaItemSourceType::Subtitle,
  ContentMediaItemSourceType::Manga,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ContentMediaItemSourceType(pub u8);
#[allow(non_upper_case_globals)]
impl ContentMediaItemSourceType {
  pub const Video: Self = Self(0);
  pub const Subtitle: Self = Self(1);
  pub const Manga: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Video,
    Self::Subtitle,
    Self::Manga,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Video => Some("Video"),
      Self::Subtitle => Some("Subtitle"),
      Self::Manga => Some("Manga"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for ContentMediaItemSourceType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for ContentMediaItemSourceType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for ContentMediaItemSourceType {
    type Output = ContentMediaItemSourceType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ContentMediaItemSourceType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for ContentMediaItemSourceType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for ContentMediaItemSourceType {}
pub enum ContentInfoOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentInfo<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentInfo<'a> {
  type Inner = ContentInfo<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentInfo<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_TITLE: flatbuffers::VOffsetT = 6;
  pub const VT_SECONDARY_TITLE: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentInfo { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentInfoArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentInfo<'bldr>> {
    let mut builder = ContentInfoBuilder::new(_fbb);
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.secondary_title { builder.add_secondary_title(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentInfo::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentInfo::VT_TITLE, None).unwrap()}
  }
  #[inline]
  pub fn secondary_title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentInfo::VT_SECONDARY_TITLE, None)}
  }
  #[inline]
  pub fn image(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentInfo::VT_IMAGE, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ContentInfo<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("secondary_title", Self::VT_SECONDARY_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, true)?
     .finish();
    Ok(())
  }
}
pub struct ContentInfoArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub secondary_title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ContentInfoArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentInfoArgs {
      id: None, // required field
      title: None, // required field
      secondary_title: None,
      image: None, // required field
    }
  }
}

pub struct ContentInfoBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentInfoBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentInfo::VT_ID, id);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentInfo::VT_TITLE, title);
  }
  #[inline]
  pub fn add_secondary_title(&mut self, secondary_title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentInfo::VT_SECONDARY_TITLE, secondary_title);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentInfo::VT_IMAGE, image);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentInfoBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentInfoBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentInfo<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentInfo::VT_ID,"id");
    self.fbb_.required(o, ContentInfo::VT_TITLE,"title");
    self.fbb_.required(o, ContentInfo::VT_IMAGE,"image");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentInfo<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentInfo");
      ds.field("id", &self.id());
      ds.field("title", &self.title());
      ds.field("secondary_title", &self.secondary_title());
      ds.field("image", &self.image());
      ds.finish()
  }
}
pub enum ContentDetailsOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentDetails<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentDetails<'a> {
  type Inner = ContentDetails<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentDetails<'a> {
  pub const VT_TITLE: flatbuffers::VOffsetT = 4;
  pub const VT_ORIGINAL_TITLE: flatbuffers::VOffsetT = 6;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 8;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 10;
  pub const VT_MEDIA_TYPE: flatbuffers::VOffsetT = 12;
  pub const VT_ADDITIONAL_INFO: flatbuffers::VOffsetT = 14;
  pub const VT_SIMILAR: flatbuffers::VOffsetT = 16;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentDetails { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentDetailsArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentDetails<'bldr>> {
    let mut builder = ContentDetailsBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.similar { builder.add_similar(x); }
    if let Some(x) = args.additional_info { builder.add_additional_info(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.original_title { builder.add_original_title(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    builder.add_media_type(args.media_type);
    builder.finish()
  }


  #[inline]
  pub fn title(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentDetails::VT_TITLE, None).unwrap()}
  }
  #[inline]
  pub fn original_title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentDetails::VT_ORIGINAL_TITLE, None)}
  }
  #[inline]
  pub fn image(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentDetails::VT_IMAGE, None).unwrap()}
  }
  #[inline]
  pub fn description(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentDetails::VT_DESCRIPTION, None).unwrap()}
  }
  #[inline]
  pub fn media_type(&self) -> MediaType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MediaType>(ContentDetails::VT_MEDIA_TYPE, Some(MediaType::Video)).unwrap()}
  }
  #[inline]
  pub fn additional_info(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ContentDetails::VT_ADDITIONAL_INFO, None)}
  }
  #[inline]
  pub fn similar(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentInfo>>>>(ContentDetails::VT_SIMILAR, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ContentDetails::VT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for ContentDetails<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("original_title", Self::VT_ORIGINAL_TITLE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, true)?
     .visit_field::<MediaType>("media_type", Self::VT_MEDIA_TYPE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("additional_info", Self::VT_ADDITIONAL_INFO, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentInfo>>>>("similar", Self::VT_SIMILAR, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContentDetailsArgs<'a> {
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub original_title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub media_type: MediaType,
    pub additional_info: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub similar: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentInfo<'a>>>>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ContentDetailsArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentDetailsArgs {
      title: None, // required field
      original_title: None,
      image: None, // required field
      description: None, // required field
      media_type: MediaType::Video,
      additional_info: None,
      similar: None,
      params: None,
    }
  }
}

pub struct ContentDetailsBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentDetailsBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_TITLE, title);
  }
  #[inline]
  pub fn add_original_title(&mut self, original_title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_ORIGINAL_TITLE, original_title);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_media_type(&mut self, media_type: MediaType) {
    self.fbb_.push_slot::<MediaType>(ContentDetails::VT_MEDIA_TYPE, media_type, MediaType::Video);
  }
  #[inline]
  pub fn add_additional_info(&mut self, additional_info: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_ADDITIONAL_INFO, additional_info);
  }
  #[inline]
  pub fn add_similar(&mut self, similar: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_SIMILAR, similar);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetails::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentDetailsBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentDetailsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentDetails<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentDetails::VT_TITLE,"title");
    self.fbb_.required(o, ContentDetails::VT_IMAGE,"image");
    self.fbb_.required(o, ContentDetails::VT_DESCRIPTION,"description");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentDetails<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentDetails");
      ds.field("title", &self.title());
      ds.field("original_title", &self.original_title());
      ds.field("image", &self.image());
      ds.field("description", &self.description());
      ds.field("media_type", &self.media_type());
      ds.field("additional_info", &self.additional_info());
      ds.field("similar", &self.similar());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum ContentMediaItemOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentMediaItem<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentMediaItem<'a> {
  type Inner = ContentMediaItem<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentMediaItem<'a> {
  pub const VT_NUMBER: flatbuffers::VOffsetT = 4;
  pub const VT_TITLE: flatbuffers::VOffsetT = 6;
  pub const VT_SECTION: flatbuffers::VOffsetT = 8;
  pub const VT_IMAGE: flatbuffers::VOffsetT = 10;
  pub const VT_SOURCES: flatbuffers::VOffsetT = 12;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 14;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentMediaItem { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentMediaItemArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentMediaItem<'bldr>> {
    let mut builder = ContentMediaItemBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.sources { builder.add_sources(x); }
    if let Some(x) = args.image { builder.add_image(x); }
    if let Some(x) = args.section { builder.add_section(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    builder.add_number(args.number);
    builder.finish()
  }


  #[inline]
  pub fn number(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(ContentMediaItem::VT_NUMBER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentMediaItem::VT_TITLE, None).unwrap()}
  }
  #[inline]
  pub fn section(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentMediaItem::VT_SECTION, None)}
  }
  #[inline]
  pub fn image(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentMediaItem::VT_IMAGE, None)}
  }
  #[inline]
  pub fn sources(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItemSource<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItemSource>>>>(ContentMediaItem::VT_SOURCES, None)}
  }
  #[inline]
  pub fn params(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ContentMediaItem::VT_PARAMS, None)}
  }
}

impl flatbuffers::Verifiable for ContentMediaItem<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("number", Self::VT_NUMBER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("section", Self::VT_SECTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("image", Self::VT_IMAGE, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentMediaItemSource>>>>("sources", Self::VT_SOURCES, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContentMediaItemArgs<'a> {
    pub number: u32,
    pub title: Option<flatbuffers::WIPOffset<&'a str>>,
    pub section: Option<flatbuffers::WIPOffset<&'a str>>,
    pub image: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sources: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItemSource<'a>>>>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ContentMediaItemArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentMediaItemArgs {
      number: 0,
      title: None, // required field
      section: None,
      image: None,
      sources: None,
      params: None,
    }
  }
}

pub struct ContentMediaItemBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentMediaItemBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_number(&mut self, number: u32) {
    self.fbb_.push_slot::<u32>(ContentMediaItem::VT_NUMBER, number, 0);
  }
  #[inline]
  pub fn add_title(&mut self, title: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItem::VT_TITLE, title);
  }
  #[inline]
  pub fn add_section(&mut self, section: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItem::VT_SECTION, section);
  }
  #[inline]
  pub fn add_image(&mut self, image: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItem::VT_IMAGE, image);
  }
  #[inline]
  pub fn add_sources(&mut self, sources: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentMediaItemSource<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItem::VT_SOURCES, sources);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItem::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentMediaItemBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentMediaItemBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentMediaItem<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentMediaItem::VT_TITLE,"title");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentMediaItem<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentMediaItem");
      ds.field("number", &self.number());
      ds.field("title", &self.title());
      ds.field("section", &self.section());
      ds.field("image", &self.image());
      ds.field("sources", &self.sources());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum HeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
  type Inner = Header<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Header<'a> {
  pub const VT_NAME: flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Header { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HeaderArgs<'args>
  ) -> flatbuffers::WIPOffset<Header<'bldr>> {
    let mut builder = HeaderBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_NAME, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_VALUE, None)}
  }
}

impl flatbuffers::Verifiable for Header<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct HeaderArgs<'a> {
    pub name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for HeaderArgs<'a> {
  #[inline]
  fn default() -> Self {
    HeaderArgs {
      name: None,
      value: None,
    }
  }
}

pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Header<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Header");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum ContentMediaItemSourceOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentMediaItemSource<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentMediaItemSource<'a> {
  type Inner = ContentMediaItemSource<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentMediaItemSource<'a> {
  pub const VT_TYPE_: flatbuffers::VOffsetT = 4;
  pub const VT_DESCRIPTION: flatbuffers::VOffsetT = 6;
  pub const VT_HEADERS: flatbuffers::VOffsetT = 8;
  pub const VT_LINKS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentMediaItemSource { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentMediaItemSourceArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentMediaItemSource<'bldr>> {
    let mut builder = ContentMediaItemSourceBuilder::new(_fbb);
    if let Some(x) = args.links { builder.add_links(x); }
    if let Some(x) = args.headers { builder.add_headers(x); }
    if let Some(x) = args.description { builder.add_description(x); }
    builder.add_type_(args.type_);
    builder.finish()
  }


  #[inline]
  pub fn type_(&self) -> ContentMediaItemSourceType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ContentMediaItemSourceType>(ContentMediaItemSource::VT_TYPE_, Some(ContentMediaItemSourceType::Video)).unwrap()}
  }
  #[inline]
  pub fn description(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentMediaItemSource::VT_DESCRIPTION, None).unwrap()}
  }
  #[inline]
  pub fn headers(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header>>>>(ContentMediaItemSource::VT_HEADERS, None)}
  }
  #[inline]
  pub fn links(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ContentMediaItemSource::VT_LINKS, None)}
  }
}

impl flatbuffers::Verifiable for ContentMediaItemSource<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<ContentMediaItemSourceType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("description", Self::VT_DESCRIPTION, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Header>>>>("headers", Self::VT_HEADERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("links", Self::VT_LINKS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContentMediaItemSourceArgs<'a> {
    pub type_: ContentMediaItemSourceType,
    pub description: Option<flatbuffers::WIPOffset<&'a str>>,
    pub headers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Header<'a>>>>>,
    pub links: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ContentMediaItemSourceArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentMediaItemSourceArgs {
      type_: ContentMediaItemSourceType::Video,
      description: None, // required field
      headers: None,
      links: None,
    }
  }
}

pub struct ContentMediaItemSourceBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentMediaItemSourceBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_type_(&mut self, type_: ContentMediaItemSourceType) {
    self.fbb_.push_slot::<ContentMediaItemSourceType>(ContentMediaItemSource::VT_TYPE_, type_, ContentMediaItemSourceType::Video);
  }
  #[inline]
  pub fn add_description(&mut self, description: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItemSource::VT_DESCRIPTION, description);
  }
  #[inline]
  pub fn add_headers(&mut self, headers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Header<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItemSource::VT_HEADERS, headers);
  }
  #[inline]
  pub fn add_links(&mut self, links: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentMediaItemSource::VT_LINKS, links);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentMediaItemSourceBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentMediaItemSourceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentMediaItemSource<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentMediaItemSource::VT_DESCRIPTION,"description");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentMediaItemSource<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentMediaItemSource");
      ds.field("type_", &self.type_());
      ds.field("description", &self.description());
      ds.field("headers", &self.headers());
      ds.field("links", &self.links());
      ds.finish()
  }
}
pub enum SuppliersResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SuppliersRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SuppliersRes<'a> {
  type Inner = SuppliersRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SuppliersRes<'a> {
  pub const VT_SUPPLIERS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SuppliersRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SuppliersResArgs<'args>
  ) -> flatbuffers::WIPOffset<SuppliersRes<'bldr>> {
    let mut builder = SuppliersResBuilder::new(_fbb);
    if let Some(x) = args.suppliers { builder.add_suppliers(x); }
    builder.finish()
  }


  #[inline]
  pub fn suppliers(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SuppliersRes::VT_SUPPLIERS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SuppliersRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("suppliers", Self::VT_SUPPLIERS, true)?
     .finish();
    Ok(())
  }
}
pub struct SuppliersResArgs<'a> {
    pub suppliers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SuppliersResArgs<'a> {
  #[inline]
  fn default() -> Self {
    SuppliersResArgs {
      suppliers: None, // required field
    }
  }
}

pub struct SuppliersResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SuppliersResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_suppliers(&mut self, suppliers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SuppliersRes::VT_SUPPLIERS, suppliers);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SuppliersResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SuppliersResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SuppliersRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SuppliersRes::VT_SUPPLIERS,"suppliers");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SuppliersRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SuppliersRes");
      ds.field("suppliers", &self.suppliers());
      ds.finish()
  }
}
pub enum SupplierNameReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SupplierNameReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SupplierNameReq<'a> {
  type Inner = SupplierNameReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SupplierNameReq<'a> {
  pub const VT_SUPPLIER: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SupplierNameReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SupplierNameReqArgs<'args>
  ) -> flatbuffers::WIPOffset<SupplierNameReq<'bldr>> {
    let mut builder = SupplierNameReqBuilder::new(_fbb);
    if let Some(x) = args.supplier { builder.add_supplier(x); }
    builder.finish()
  }


  #[inline]
  pub fn supplier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SupplierNameReq::VT_SUPPLIER, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for SupplierNameReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supplier", Self::VT_SUPPLIER, true)?
     .finish();
    Ok(())
  }
}
pub struct SupplierNameReqArgs<'a> {
    pub supplier: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SupplierNameReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    SupplierNameReqArgs {
      supplier: None, // required field
    }
  }
}

pub struct SupplierNameReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SupplierNameReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_supplier(&mut self, supplier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SupplierNameReq::VT_SUPPLIER, supplier);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SupplierNameReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SupplierNameReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SupplierNameReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SupplierNameReq::VT_SUPPLIER,"supplier");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SupplierNameReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SupplierNameReq");
      ds.field("supplier", &self.supplier());
      ds.finish()
  }
}
pub enum ChannelsResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ChannelsRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ChannelsRes<'a> {
  type Inner = ChannelsRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ChannelsRes<'a> {
  pub const VT_CHANNELS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ChannelsRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ChannelsResArgs<'args>
  ) -> flatbuffers::WIPOffset<ChannelsRes<'bldr>> {
    let mut builder = ChannelsResBuilder::new(_fbb);
    if let Some(x) = args.channels { builder.add_channels(x); }
    builder.finish()
  }


  #[inline]
  pub fn channels(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(ChannelsRes::VT_CHANNELS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ChannelsRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("channels", Self::VT_CHANNELS, true)?
     .finish();
    Ok(())
  }
}
pub struct ChannelsResArgs<'a> {
    pub channels: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for ChannelsResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ChannelsResArgs {
      channels: None, // required field
    }
  }
}

pub struct ChannelsResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ChannelsResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_channels(&mut self, channels: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ChannelsRes::VT_CHANNELS, channels);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ChannelsResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ChannelsResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ChannelsRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ChannelsRes::VT_CHANNELS,"channels");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ChannelsRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ChannelsRes");
      ds.field("channels", &self.channels());
      ds.finish()
  }
}
pub enum SupportedTypesResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SupportedTypesRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SupportedTypesRes<'a> {
  type Inner = SupportedTypesRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SupportedTypesRes<'a> {
  pub const VT_TYPES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SupportedTypesRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SupportedTypesResArgs<'args>
  ) -> flatbuffers::WIPOffset<SupportedTypesRes<'bldr>> {
    let mut builder = SupportedTypesResBuilder::new(_fbb);
    if let Some(x) = args.types { builder.add_types(x); }
    builder.finish()
  }


  #[inline]
  pub fn types(&self) -> Option<flatbuffers::Vector<'a, ContentType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ContentType>>>(SupportedTypesRes::VT_TYPES, None)}
  }
}

impl flatbuffers::Verifiable for SupportedTypesRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ContentType>>>("types", Self::VT_TYPES, false)?
     .finish();
    Ok(())
  }
}
pub struct SupportedTypesResArgs<'a> {
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ContentType>>>,
}
impl<'a> Default for SupportedTypesResArgs<'a> {
  #[inline]
  fn default() -> Self {
    SupportedTypesResArgs {
      types: None,
    }
  }
}

pub struct SupportedTypesResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SupportedTypesResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ContentType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SupportedTypesRes::VT_TYPES, types);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SupportedTypesResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SupportedTypesResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SupportedTypesRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SupportedTypesRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SupportedTypesRes");
      ds.field("types", &self.types());
      ds.finish()
  }
}
pub enum SupportedLanuagesResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SupportedLanuagesRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SupportedLanuagesRes<'a> {
  type Inner = SupportedLanuagesRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SupportedLanuagesRes<'a> {
  pub const VT_LANGS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SupportedLanuagesRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SupportedLanuagesResArgs<'args>
  ) -> flatbuffers::WIPOffset<SupportedLanuagesRes<'bldr>> {
    let mut builder = SupportedLanuagesResBuilder::new(_fbb);
    if let Some(x) = args.langs { builder.add_langs(x); }
    builder.finish()
  }


  #[inline]
  pub fn langs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(SupportedLanuagesRes::VT_LANGS, None)}
  }
}

impl flatbuffers::Verifiable for SupportedLanuagesRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("langs", Self::VT_LANGS, false)?
     .finish();
    Ok(())
  }
}
pub struct SupportedLanuagesResArgs<'a> {
    pub langs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for SupportedLanuagesResArgs<'a> {
  #[inline]
  fn default() -> Self {
    SupportedLanuagesResArgs {
      langs: None,
    }
  }
}

pub struct SupportedLanuagesResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SupportedLanuagesResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_langs(&mut self, langs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SupportedLanuagesRes::VT_LANGS, langs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SupportedLanuagesResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SupportedLanuagesResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SupportedLanuagesRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SupportedLanuagesRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SupportedLanuagesRes");
      ds.field("langs", &self.langs());
      ds.finish()
  }
}
pub enum LoadChannelsReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LoadChannelsReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoadChannelsReq<'a> {
  type Inner = LoadChannelsReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoadChannelsReq<'a> {
  pub const VT_SUPPLIER: flatbuffers::VOffsetT = 4;
  pub const VT_CHANNEL: flatbuffers::VOffsetT = 6;
  pub const VT_PAGE: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoadChannelsReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LoadChannelsReqArgs<'args>
  ) -> flatbuffers::WIPOffset<LoadChannelsReq<'bldr>> {
    let mut builder = LoadChannelsReqBuilder::new(_fbb);
    builder.add_page(args.page);
    if let Some(x) = args.channel { builder.add_channel(x); }
    if let Some(x) = args.supplier { builder.add_supplier(x); }
    builder.finish()
  }


  #[inline]
  pub fn supplier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoadChannelsReq::VT_SUPPLIER, None).unwrap()}
  }
  #[inline]
  pub fn channel(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoadChannelsReq::VT_CHANNEL, None).unwrap()}
  }
  #[inline]
  pub fn page(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(LoadChannelsReq::VT_PAGE, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoadChannelsReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supplier", Self::VT_SUPPLIER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("channel", Self::VT_CHANNEL, true)?
     .visit_field::<u32>("page", Self::VT_PAGE, false)?
     .finish();
    Ok(())
  }
}
pub struct LoadChannelsReqArgs<'a> {
    pub supplier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub channel: Option<flatbuffers::WIPOffset<&'a str>>,
    pub page: u32,
}
impl<'a> Default for LoadChannelsReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    LoadChannelsReqArgs {
      supplier: None, // required field
      channel: None, // required field
      page: 0,
    }
  }
}

pub struct LoadChannelsReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LoadChannelsReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_supplier(&mut self, supplier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadChannelsReq::VT_SUPPLIER, supplier);
  }
  #[inline]
  pub fn add_channel(&mut self, channel: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadChannelsReq::VT_CHANNEL, channel);
  }
  #[inline]
  pub fn add_page(&mut self, page: u32) {
    self.fbb_.push_slot::<u32>(LoadChannelsReq::VT_PAGE, page, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LoadChannelsReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LoadChannelsReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoadChannelsReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LoadChannelsReq::VT_SUPPLIER,"supplier");
    self.fbb_.required(o, LoadChannelsReq::VT_CHANNEL,"channel");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoadChannelsReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoadChannelsReq");
      ds.field("supplier", &self.supplier());
      ds.field("channel", &self.channel());
      ds.field("page", &self.page());
      ds.finish()
  }
}
pub enum SearchReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SearchReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SearchReq<'a> {
  type Inner = SearchReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SearchReq<'a> {
  pub const VT_SUPPLIER: flatbuffers::VOffsetT = 4;
  pub const VT_QUERY: flatbuffers::VOffsetT = 6;
  pub const VT_TYPES: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SearchReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SearchReqArgs<'args>
  ) -> flatbuffers::WIPOffset<SearchReq<'bldr>> {
    let mut builder = SearchReqBuilder::new(_fbb);
    if let Some(x) = args.types { builder.add_types(x); }
    if let Some(x) = args.query { builder.add_query(x); }
    if let Some(x) = args.supplier { builder.add_supplier(x); }
    builder.finish()
  }


  #[inline]
  pub fn supplier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SearchReq::VT_SUPPLIER, None).unwrap()}
  }
  #[inline]
  pub fn query(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SearchReq::VT_QUERY, None).unwrap()}
  }
  #[inline]
  pub fn types(&self) -> Option<flatbuffers::Vector<'a, ContentType>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, ContentType>>>(SearchReq::VT_TYPES, None)}
  }
}

impl flatbuffers::Verifiable for SearchReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supplier", Self::VT_SUPPLIER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("query", Self::VT_QUERY, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, ContentType>>>("types", Self::VT_TYPES, false)?
     .finish();
    Ok(())
  }
}
pub struct SearchReqArgs<'a> {
    pub supplier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub query: Option<flatbuffers::WIPOffset<&'a str>>,
    pub types: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ContentType>>>,
}
impl<'a> Default for SearchReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    SearchReqArgs {
      supplier: None, // required field
      query: None, // required field
      types: None,
    }
  }
}

pub struct SearchReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SearchReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_supplier(&mut self, supplier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchReq::VT_SUPPLIER, supplier);
  }
  #[inline]
  pub fn add_query(&mut self, query: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchReq::VT_QUERY, query);
  }
  #[inline]
  pub fn add_types(&mut self, types: flatbuffers::WIPOffset<flatbuffers::Vector<'b , ContentType>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SearchReq::VT_TYPES, types);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SearchReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SearchReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SearchReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, SearchReq::VT_SUPPLIER,"supplier");
    self.fbb_.required(o, SearchReq::VT_QUERY,"query");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SearchReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SearchReq");
      ds.field("supplier", &self.supplier());
      ds.field("query", &self.query());
      ds.field("types", &self.types());
      ds.finish()
  }
}
pub enum ContentInfoResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentInfoRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentInfoRes<'a> {
  type Inner = ContentInfoRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentInfoRes<'a> {
  pub const VT_ITEMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentInfoRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentInfoResArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentInfoRes<'bldr>> {
    let mut builder = ContentInfoResBuilder::new(_fbb);
    if let Some(x) = args.items { builder.add_items(x); }
    builder.finish()
  }


  #[inline]
  pub fn items(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentInfo<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentInfo>>>>(ContentInfoRes::VT_ITEMS, None)}
  }
}

impl flatbuffers::Verifiable for ContentInfoRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentInfo>>>>("items", Self::VT_ITEMS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContentInfoResArgs<'a> {
    pub items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentInfo<'a>>>>>,
}
impl<'a> Default for ContentInfoResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentInfoResArgs {
      items: None,
    }
  }
}

pub struct ContentInfoResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentInfoResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_items(&mut self, items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentInfo<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentInfoRes::VT_ITEMS, items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentInfoResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentInfoResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentInfoRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentInfoRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentInfoRes");
      ds.field("items", &self.items());
      ds.finish()
  }
}
pub enum ContentDetailsReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentDetailsReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentDetailsReq<'a> {
  type Inner = ContentDetailsReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentDetailsReq<'a> {
  pub const VT_SUPPLIER: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentDetailsReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentDetailsReqArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentDetailsReq<'bldr>> {
    let mut builder = ContentDetailsReqBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.supplier { builder.add_supplier(x); }
    builder.finish()
  }


  #[inline]
  pub fn supplier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentDetailsReq::VT_SUPPLIER, None).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(ContentDetailsReq::VT_ID, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for ContentDetailsReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supplier", Self::VT_SUPPLIER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .finish();
    Ok(())
  }
}
pub struct ContentDetailsReqArgs<'a> {
    pub supplier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ContentDetailsReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentDetailsReqArgs {
      supplier: None, // required field
      id: None, // required field
    }
  }
}

pub struct ContentDetailsReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentDetailsReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_supplier(&mut self, supplier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetailsReq::VT_SUPPLIER, supplier);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ContentDetailsReq::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentDetailsReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentDetailsReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentDetailsReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, ContentDetailsReq::VT_SUPPLIER,"supplier");
    self.fbb_.required(o, ContentDetailsReq::VT_ID,"id");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentDetailsReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentDetailsReq");
      ds.field("supplier", &self.supplier());
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum ContentDetailsResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ContentDetailsRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ContentDetailsRes<'a> {
  type Inner = ContentDetailsRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> ContentDetailsRes<'a> {
  pub const VT_DETAILS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ContentDetailsRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ContentDetailsResArgs<'args>
  ) -> flatbuffers::WIPOffset<ContentDetailsRes<'bldr>> {
    let mut builder = ContentDetailsResBuilder::new(_fbb);
    if let Some(x) = args.details { builder.add_details(x); }
    builder.finish()
  }


  #[inline]
  pub fn details(&self) -> Option<ContentDetails<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<ContentDetails>>(ContentDetailsRes::VT_DETAILS, None)}
  }
}

impl flatbuffers::Verifiable for ContentDetailsRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<ContentDetails>>("details", Self::VT_DETAILS, false)?
     .finish();
    Ok(())
  }
}
pub struct ContentDetailsResArgs<'a> {
    pub details: Option<flatbuffers::WIPOffset<ContentDetails<'a>>>,
}
impl<'a> Default for ContentDetailsResArgs<'a> {
  #[inline]
  fn default() -> Self {
    ContentDetailsResArgs {
      details: None,
    }
  }
}

pub struct ContentDetailsResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ContentDetailsResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_details(&mut self, details: flatbuffers::WIPOffset<ContentDetails<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<ContentDetails>>(ContentDetailsRes::VT_DETAILS, details);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ContentDetailsResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ContentDetailsResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ContentDetailsRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ContentDetailsRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ContentDetailsRes");
      ds.field("details", &self.details());
      ds.finish()
  }
}
pub enum LoadMediaItemsReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LoadMediaItemsReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoadMediaItemsReq<'a> {
  type Inner = LoadMediaItemsReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoadMediaItemsReq<'a> {
  pub const VT_SUPPLIER: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoadMediaItemsReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LoadMediaItemsReqArgs<'args>
  ) -> flatbuffers::WIPOffset<LoadMediaItemsReq<'bldr>> {
    let mut builder = LoadMediaItemsReqBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.supplier { builder.add_supplier(x); }
    builder.finish()
  }


  #[inline]
  pub fn supplier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoadMediaItemsReq::VT_SUPPLIER, None).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoadMediaItemsReq::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn params(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LoadMediaItemsReq::VT_PARAMS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoadMediaItemsReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supplier", Self::VT_SUPPLIER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, true)?
     .finish();
    Ok(())
  }
}
pub struct LoadMediaItemsReqArgs<'a> {
    pub supplier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LoadMediaItemsReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    LoadMediaItemsReqArgs {
      supplier: None, // required field
      id: None, // required field
      params: None, // required field
    }
  }
}

pub struct LoadMediaItemsReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LoadMediaItemsReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_supplier(&mut self, supplier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemsReq::VT_SUPPLIER, supplier);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemsReq::VT_ID, id);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemsReq::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LoadMediaItemsReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LoadMediaItemsReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoadMediaItemsReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LoadMediaItemsReq::VT_SUPPLIER,"supplier");
    self.fbb_.required(o, LoadMediaItemsReq::VT_ID,"id");
    self.fbb_.required(o, LoadMediaItemsReq::VT_PARAMS,"params");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoadMediaItemsReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoadMediaItemsReq");
      ds.field("supplier", &self.supplier());
      ds.field("id", &self.id());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum LoadMediaItemsResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LoadMediaItemsRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoadMediaItemsRes<'a> {
  type Inner = LoadMediaItemsRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoadMediaItemsRes<'a> {
  pub const VT_MEDIA_ITEMS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoadMediaItemsRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LoadMediaItemsResArgs<'args>
  ) -> flatbuffers::WIPOffset<LoadMediaItemsRes<'bldr>> {
    let mut builder = LoadMediaItemsResBuilder::new(_fbb);
    if let Some(x) = args.media_items { builder.add_media_items(x); }
    builder.finish()
  }


  #[inline]
  pub fn media_items(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItem<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItem>>>>(LoadMediaItemsRes::VT_MEDIA_ITEMS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoadMediaItemsRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentMediaItem>>>>("media_items", Self::VT_MEDIA_ITEMS, true)?
     .finish();
    Ok(())
  }
}
pub struct LoadMediaItemsResArgs<'a> {
    pub media_items: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItem<'a>>>>>,
}
impl<'a> Default for LoadMediaItemsResArgs<'a> {
  #[inline]
  fn default() -> Self {
    LoadMediaItemsResArgs {
      media_items: None, // required field
    }
  }
}

pub struct LoadMediaItemsResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LoadMediaItemsResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_media_items(&mut self, media_items: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentMediaItem<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemsRes::VT_MEDIA_ITEMS, media_items);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LoadMediaItemsResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LoadMediaItemsResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoadMediaItemsRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LoadMediaItemsRes::VT_MEDIA_ITEMS,"media_items");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoadMediaItemsRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoadMediaItemsRes");
      ds.field("media_items", &self.media_items());
      ds.finish()
  }
}
pub enum LoadMediaItemSourcesReqOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LoadMediaItemSourcesReq<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoadMediaItemSourcesReq<'a> {
  type Inner = LoadMediaItemSourcesReq<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoadMediaItemSourcesReq<'a> {
  pub const VT_SUPPLIER: flatbuffers::VOffsetT = 4;
  pub const VT_ID: flatbuffers::VOffsetT = 6;
  pub const VT_PARAMS: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoadMediaItemSourcesReq { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LoadMediaItemSourcesReqArgs<'args>
  ) -> flatbuffers::WIPOffset<LoadMediaItemSourcesReq<'bldr>> {
    let mut builder = LoadMediaItemSourcesReqBuilder::new(_fbb);
    if let Some(x) = args.params { builder.add_params(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.supplier { builder.add_supplier(x); }
    builder.finish()
  }


  #[inline]
  pub fn supplier(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoadMediaItemSourcesReq::VT_SUPPLIER, None).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(LoadMediaItemSourcesReq::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn params(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>(LoadMediaItemSourcesReq::VT_PARAMS, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoadMediaItemSourcesReq<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("supplier", Self::VT_SUPPLIER, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>>>("params", Self::VT_PARAMS, true)?
     .finish();
    Ok(())
  }
}
pub struct LoadMediaItemSourcesReqArgs<'a> {
    pub supplier: Option<flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub params: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>>,
}
impl<'a> Default for LoadMediaItemSourcesReqArgs<'a> {
  #[inline]
  fn default() -> Self {
    LoadMediaItemSourcesReqArgs {
      supplier: None, // required field
      id: None, // required field
      params: None, // required field
    }
  }
}

pub struct LoadMediaItemSourcesReqBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LoadMediaItemSourcesReqBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_supplier(&mut self, supplier: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemSourcesReq::VT_SUPPLIER, supplier);
  }
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemSourcesReq::VT_ID, id);
  }
  #[inline]
  pub fn add_params(&mut self, params: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemSourcesReq::VT_PARAMS, params);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LoadMediaItemSourcesReqBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LoadMediaItemSourcesReqBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoadMediaItemSourcesReq<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LoadMediaItemSourcesReq::VT_SUPPLIER,"supplier");
    self.fbb_.required(o, LoadMediaItemSourcesReq::VT_ID,"id");
    self.fbb_.required(o, LoadMediaItemSourcesReq::VT_PARAMS,"params");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoadMediaItemSourcesReq<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoadMediaItemSourcesReq");
      ds.field("supplier", &self.supplier());
      ds.field("id", &self.id());
      ds.field("params", &self.params());
      ds.finish()
  }
}
pub enum LoadMediaItemSourcesResOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct LoadMediaItemSourcesRes<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for LoadMediaItemSourcesRes<'a> {
  type Inner = LoadMediaItemSourcesRes<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> LoadMediaItemSourcesRes<'a> {
  pub const VT_SOURCES: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    LoadMediaItemSourcesRes { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LoadMediaItemSourcesResArgs<'args>
  ) -> flatbuffers::WIPOffset<LoadMediaItemSourcesRes<'bldr>> {
    let mut builder = LoadMediaItemSourcesResBuilder::new(_fbb);
    if let Some(x) = args.sources { builder.add_sources(x); }
    builder.finish()
  }


  #[inline]
  pub fn sources(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItemSource<'a>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItemSource>>>>(LoadMediaItemSourcesRes::VT_SOURCES, None).unwrap()}
  }
}

impl flatbuffers::Verifiable for LoadMediaItemSourcesRes<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<ContentMediaItemSource>>>>("sources", Self::VT_SOURCES, true)?
     .finish();
    Ok(())
  }
}
pub struct LoadMediaItemSourcesResArgs<'a> {
    pub sources: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<ContentMediaItemSource<'a>>>>>,
}
impl<'a> Default for LoadMediaItemSourcesResArgs<'a> {
  #[inline]
  fn default() -> Self {
    LoadMediaItemSourcesResArgs {
      sources: None, // required field
    }
  }
}

pub struct LoadMediaItemSourcesResBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> LoadMediaItemSourcesResBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_sources(&mut self, sources: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<ContentMediaItemSource<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(LoadMediaItemSourcesRes::VT_SOURCES, sources);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> LoadMediaItemSourcesResBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LoadMediaItemSourcesResBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<LoadMediaItemSourcesRes<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, LoadMediaItemSourcesRes::VT_SOURCES,"sources");
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for LoadMediaItemSourcesRes<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("LoadMediaItemSourcesRes");
      ds.field("sources", &self.sources());
      ds.finish()
  }
}
}  // pub mod Proto

